package com.mingcloud.proxy.logiclayer.messagehandler;


import com.mingcloud.proxy.datacenter.DataCenter;
import com.mingcloud.proxy.datacenter.messageData.SucmessagelogData;
import com.mingcloud.proxy.datalayer.dto.archiveinfo.MessageSourceDto;
import com.mingcloud.proxy.logiclayer.messagehandler.messagedistance.EmailMessage;
import com.mingcloud.proxy.logiclayer.messagehandler.messagedistance.MessageStrategy;
import com.mingcloud.proxy.logiclayer.messagehandler.messagedistance.OfficalWechatMessage;
import com.mingcloud.proxy.logiclayer.messagehandler.messagedistance.StorageMessage;
import com.mingcloud.proxy.logiclayer.messagehandler.messagedto.MessageDto;
import org.apache.log4j.Logger;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

/**
 * 消息输出线程
 * Created by zyn on 2018/8/8.
 */
public final class MessageSourceDataOutThread implements Runnable {

    /**
     * 日志
     */
    private static Logger logger = Logger.getLogger(MessageSourceDataOutThread.class);

    private DataCenter dataCenter = DataCenter.getInstance();

    private static SucmessagelogData sucmessagelogData = SucmessagelogData.getInstance();

    /**
     * 发送策略
     */
    private static MessageStrategy emailMessage = EmailMessage.getInstance();

    private static MessageStrategy officalWechatMessage = OfficalWechatMessage.getInstance();

    private static MessageStrategy storageMessage = StorageMessage.getInstance();

    public void run() {
        while (true) {
            if (dataCenter.getMessageSourceListSize() > 0) {
                handleMessage();
                logger.info("MessageSourceDataCenter size: " + dataCenter.getMessageSourceListSize());
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                logger.error("MessageSourceDataOutThread: " + e);
            }
        }
    }

    /**
     * 消息发送主方法
     */
    @Transactional
    private void handleMessage() {
        try {
            if (dataCenter.getMessageSourceListSize() > 0) {
                MessageSourceDto dto = dataCenter.popMessageSourceList();
                List<Map<String, String>> sqlResultList = dto.getSqlResultList();
                for (int i = 0; i < sqlResultList.size(); i++) {
                    //是否需要清理临时数据，默认false不需要，true需要
                    boolean cleanflag = false;
                    //解析acceptor
                    cleanflag = parseAcceptors(dto.getAcceptor(), sqlResultList.get(i), cleanflag, dto);
                    synchronized (MessageSourceDataInThread.LOCK) {
                        if (cleanflag) {
                            String key = new StringBuilder(dto.getId().toString()).append(":").
                                    append(dto.getKeyword()).append(":").append(sqlResultList.get(i).get(dto.getKeyword())).toString();
                            /*MessageSourceDataInThread.jedis.del("keys", key);*/
                            MessageSourceDataInThread.keySet.remove(key);
                        }
                    }
                }
            }
        } catch (Exception e) {
            logger.error("MessageSourceOutThread.Exception: " + e);
        }
    }

    /**
     * @tiele 解析接收用户,发送消息
     * @param acceptors
     * @param resultMap
     * @param cleanflag
     * @param dto
     * @return
     */
    private boolean parseAcceptors(String acceptors, Map<String, String> resultMap, boolean cleanflag, MessageSourceDto dto) {
        String message = null;
        String content = dto.getContent();
        String[] acceptorArray = null;
        if (acceptors.indexOf("|") == -1) {
            acceptorArray = new String[]{acceptors};
        } else {
            acceptorArray = acceptors.split("\\|");
        }
        for (int i = 0; i < acceptorArray.length; i++) {
            StringBuilder acceptorbuilder = new StringBuilder(acceptorArray[i].trim());
            int lastbracket;
            String acceptor = null;
            if ((lastbracket = acceptorArray[i].indexOf("}")) != -1) {
                acceptor = resultMap.get(acceptorbuilder.delete(lastbracket, lastbracket + 1).
                        deleteCharAt(0).toString());
                if (acceptor == null || "".equals(acceptor)) {
                    cleanflag = true;
                    continue;
                }
            } else {
                acceptor = acceptorbuilder.toString();
            }
            if (message == null) {
                message = this.parseMessage(resultMap, content);
            }
            MessageDto messageDto = new MessageDto(dto, sucmessagelogData, resultMap, message, acceptor);
            switch (dto.getType()) {
                case MessageStrategy.OFFICALWECHAT:
                    cleanflag = officalWechatMessage.sendMessage(messageDto);
                    break;

                case MessageStrategy.GEELYC3:
                    cleanflag = officalWechatMessage.sendMessage(messageDto);
                    break;
                case MessageStrategy.EMAIL:
                    cleanflag = emailMessage.sendMessage(messageDto);
                    break;
                case MessageStrategy.STORAGE_MESSAGE:
                    cleanflag = storageMessage.sendMessage(messageDto);
                    break;
            }
        }
        return cleanflag;
    }

    /**
     * @tiele解析正文
     * @param resultMap
     * @param content
     * @return
     */
    private String parseMessage(Map<String, String> resultMap, String content) {
        StringBuilder message = new StringBuilder(content);
        for (Map.Entry<String, String> resultEntry : resultMap.entrySet()) {
            String replaceKey = new StringBuffer("{").append(resultEntry.getKey()).append("}").toString();
            int startIndex;
            while ((startIndex = message.indexOf(replaceKey)) != -1) {
                message = message.replace(startIndex, startIndex + replaceKey.length(), resultEntry.getValue());
            }
        }
        return message.toString();
    }
}
